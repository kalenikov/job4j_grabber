
1 Чем java отличается от с++?
    в контекст нашей беседы можно предположить что речь про автоматическую сборку мусора 
    + байт код
    + встроеная поддержка потоков
    - нет множ наследования

2 Что такое менеджер памяти?

    Менеджер памяти - часть JVM, следит за состоянием памяти, обрабатывает запросы на выделение и освобождение памяти под создаваемые объекты и при необходимости запускат еще очистки. 
    Профит: снимает с программиста ответственность за освобождение памяти.

    Менеджер памяти может быть 
        -- встроенный в ОС 
        -- частью среды исполнения. 

============================================================   
3 Какой механизм используется в Java для управления памятью?
============================================================

    Используется GC – часть JVM, которая занимается очищением памяти. 
    Он смотрит на достижимость объекта по ссылке


Модель памяти Java
    Память разделена на две основые части, которые тоже делятся на части
        -- Stack (LIFO, сильно меньше хипа)
            Выделяется для каждого потока
            Хранит ссылки на объекты кучи и значения примитивных типов

            -- Permanent Generation (c 8 -- Metaspace) – хранение метаданных

        -- Heap (ссылки на объекты и пулы строки и Int)
            Хранит объекты, на которые ссылаются переменные из стека. 
            Для каждого запущенного процесса существует только одна область памяти в куче.

            -- Young generation (когда переполняется запускается  minor GC )
                    -- eden
                    -- survivor (после первой сборки мусора)
            -- Old (когда переполняется запускается major GC )

Жизненный цикл объекта
    1. new -- выделение памяти и возрат ссылки (EDEN)
    2. п.1 повторяется пока есть место в EDEN 
        если в EDEN место кончилось, запускается minor GC
            -- удаляются unreferensed object
            -- все остальные перемещаются в часть survivor ("сувайве")
            -- move form survivor to survivor (+ aging)
            -- old object move to old generation ("promotion")
            (loop while empty size in OLD generation)
                -- magor GC


============================================================
4 Опишите процесс работы сборщика мусора?
============================================================

    ГК выполняет всего две задачи, связанные с поиском мусора и его очисткой.
    Суть работы заключается в том, чтобы отслеживает достижимость объектов по ссылкам и преднимать некоторые действие, в зависимости от конктретного алгоритма.
    Главная идея связана с тем, что до «живого» объекта можно добраться из корневых точек (GC Root).

        GC Root
        -- Основной Java поток.
        -- Локальные переменные в основном методе.
        -- Статические переменные основного класса.


============================================================
5 Какие алгоритмы сборщика вы знаете
============================================================

    Основные алгоритмы, которые используют GC в своей работе:

    Mark-and-sweep (в чистом виде не используется)
        1 «Mark»: помечаются неиспользуемые объекты.
        2 «Sweep»: эти объекты удаляются из памяти.
        - необходимость остановки
        - время сборки зависит от колва памяти 

    mark-sweep-compact
        1 «Mark»: помечаются неиспользуемые объекты.
        2 «Sweep»: эти объекты удаляются из памяти.
        3 «Compact»: объекты «уплотняются», занимая свободные слоты, что освобождает пространство 
        4 На протяжении всех трех шагов действует «stop-the-world» пауза.

    Copying Collector
        Памяти делится на две части : в одной части объекты, а вторая часть пустая. 
        На время очистки app останавливает работу и запускается ГК, который находит в 1й области объекты со ссылками и переносит их во 2ю область. 
        После этого, 1я область очищается от оставшихся там объектов без ссылок, и области меняются местами
        + плотное заполнеие памяти
        - необходимость остановки
        - иметь две пустые одинаковые области памяти

============================================================   
6 Чем отличаются сборщики мусора?
============================================================

    Тем, какие алгоритмы работы они используют.
    Во-первых, использования количество ядер процессора: 
        1 Последовательное (Serial) -- выполняется только в 1 потоке и задействует только 1 процессор  
        2 Параллельное (Parallel) -- использовать несколько процессоров и за счет этого распараллеливания сборки
        
    Во-вторых, по типу использованию параллелизм (Concurrency) или Stop-The-World 
        (нужно ли полностю останавливать приложения для очистки)

        1. Stop The World -- чтобы очистить память нужно остановить приложение
        2. Параллелизм (работает одновременно с самим приложением) 
        -- он постоянно производит небольшие очистки и не ждет пока heap заполнится полностью/
        -- вызывают недолгие событие Stop The World

    В-третьих, по видам сборки: 
        -- (уплотнение) Compacting -- собрать "живые" объекты в одном месте и очистить оставшуюся часть памяти.
            + легко выделить память
            - время на компановку объектов в одном месте
        -- Non-compacting (удалить объекты по месту)
            + нет лишних действий
            - дефрагментация памяти
        -- Copying
            скопировать "живые" объекты в отдельную часть памяти, очистив старую часть где они были
            + нет проблем на выделение памятие
            - требуется время на копирование

============================================================
Конкретные примеры ГК
============================================================

    1. Serial GC (однопоточный)
        Stop The World + mark-and-sweep + сopying (young gen) + compact (old gen) 
        + мин требования
        - медленный В основном относится к небольшим приложениям с небольшим использованием данных.

    2. Parallel ("паралал") GC (Parallel, Stop The World, Copying) - использует тот же алгоритм сборки что и Serial,
        в  нескольких потоках, требует несколько ядер.
        в несколько потоков для minor collection и один поток для full garbage collection
        Подходит для использования на серверах так как имеет меньше STW events.

        Parallel Old, -XX:+UseParallelOldGC - то же что и Parallel, но использует несколько потоков также для полной сборки. Предпочтительнее, чем ParallelGC.

    3. CMS (Убран с JDK 14)(Concurrent Mark Sweep, Parallel, Concurrent, Copying) 
        -- спользуется параллелизм, т.е. часть heap чистится одновременно с работой приложения.
        + небольшие паузы
        - более высокие сист требования

    4. G1 (CMS+. Parallel, Concurrent, Copying)
         используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз 
        + скорость
        - нужен большой heap (> 4gb)

    5. ZGC ( Parallel, Concurrent, Copying) - появился в ЖДК11
        + не требует остановки приложения, используется для серверных приложений где допустимы лишь паузы < 10ms
        - требует огромный heap в несколько Тб


============================================================
Метрики
============================================================

    1. Пропускная способность (Thoughput) - соотношение, сколько GC может работать без полной сборки мусора
        == (1 - время_на_сборки / общ_время) * 100
    2. Время на сборку (GC Overhead) - соотношение, сколько требуется времени на сборку
        == (время_на_сборки / общ_время) * 100
    3. Время остановки (Pause Time, Latency) - время на которое требуется остановить приложение доя сборки
    4. Частота сборок (Freequency of collection) - количество сборок за все время работы
    5. Оперативность (Promptness) -- время между началом сборки и моментом, когда память снова становится доступной для размещения объектов.
    6. Сколько памяти доступное программе (Footprint) 

   
============================================================
7 Утилиты для анализа памяти
============================================================

    jps -- показывает информацию о запущенных процессах JVM 
    анализатор запущенных процессов (для пределения идентификатора процесса)

    jstat 
        -- Отображает статистику \ сводную информацию о состоянии памяти программы (узнать размер памяти или алгоритм сборщика)
        Делает сэмприлование, т.е. получает данные о состоянии разных участков памяти и их обобщает.
 

    jmap -- умеет дампить хип или строить гистограмму (считает сколько места занимают объекты каждого класса)
        Из этой гистограммы можно понять, какие объекты больше всего мусорят в хипе.
        
    jsoncole -- GUI-инструмент для мониторинга и управления как локальными, так и удаленными JVM и приложениями.
        - состояние памяти (сколько заняти в разных отделах)
        - данные о потоках (количество запущенныъ)
        - сводную информацию о классах (количество загруженых)
        - сводную инфу о приложении ()
    

============================================================
9 Ссылки. Какие типы ссылок вы знаете? Чем они отличаются?
============================================================

    Ссылка - Это указатель на место в heap где хранится обьект.
    
    Strong - пока жива ссылка, жив и обьект 
    soft - обьект хранится до тех пор пока не кончится память. 
    weak - удалится при первой же сборки мусора. 
    phantom его метод get() всегщда возвращает null. Используется вместе с спец.очередью

    Strong Reference -- обычные ссылки. 
        Любой объект, который имеет strong-ссылку, запрещен для удаления ГК. 
        Проблема -- если в программе есть неиспользуемые ссылки на созданные объекты, то они не будут удалены.

    Soft Reference (для реализации кэшей) 
        Объекты, на которые ссылаются SoftReference, удаляются только если JVM не хватает памяти, т.е. они могут пережить более одной сборки мусора.  
        Есть контракт для SoftReference: GC гарантировано удалит все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError.

    WeakReference 
        Объекты, на которые ссылаются WeakReference, удаляются сразу, если на них Strong или Soft. 
        Используется:: для хранения метаданных, например для хранения ссылки на ClassLoader.

    PhantomReference
        Phantom Reference - в отличие от Soft и Weak, Phantom не дает исходной ссылки на объект, даже если объект еще жив. Используется для взаимодействия с GC, мониторинга когда объект собирается, заменяет использование метода finalize. 
        Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная фантомная ссылка не очищена с помощью вызова метода clear().  
        Этот тип ссылок в комбинации с ReferenceQueue позволяет нам узнать, когда объект более недоступен и на него нет других ссылок.

        При наличие на объект только фантомной ссылки, сборщик мусора предпринимает следующие действия по утилизации объекта:
            -- Выполняет метод finalize().
            -- Если после выполнения предыдущего шага на объект не было создано жестких ссылок и объект может быть удален из памяти, то фантомная ссылка помещается в очередь ReferenceQueue.

        Обычная практика - создать отдельный поток, который будет проверять ReferenceQueue
        Когда из очереди считывается не пустое значение, вызываем метод класса-наследника для очистки
        (http://samolisov.blogspot.com/2011/09/phantomreferences-java.html)

        Особенности
        -- метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue. 
        -- в отличие от Soft и Weak, GC добавит phantom-ссылку в ReferenceQueue ПОСЛЕ ТОГО как выполниться метод finalize(). Тоесть фактически, в отличии от SoftReference и WeakReference, объект еще есть в памяти.
 
        Это позволяет нам сделать очистку ресурсов, используемых объектом, на уровне приложения.
        В отличии от finalize() мы сами контролируем процесс очистки ресурсов. 
        Объект не удаляется из памяти до тех пор, пока его фантомная ссылка находится в ReferenceQueue.

        Создаются с помощью вызова new PhantomReference<T>(T obj, ReferenceQueue<T> queue). 
        Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная фантомная ссылка не очищена с помощью вызова метода clear(). Так же стоит заметить, что метод get() фантомной ссылки всегда возвращает null.

    ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться ссылки после удаления.

    WeakHashMap. Это реализация Map<K,V> которая хранит ключ, используя weak-ссылку. 
    Когда GC удаляет ключ из памяти, то удаляется вся запись с Map. 


============================================================
11 String pool, Int pool
============================================================

    Пул строк – это набор строк, который хранится в Heap. 
    Когда мы используем двойные кавычки для создания строки (созданная как строковый литерал), сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. 
    При использовании NEW, мы принуждаем класс String создать новый объект строки

    В Java есть пул(pool) целых чисел в промежутке [-128;127]. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула. 

============================================================
12 String.intern()
============================================================

    Это оператор для интернирования строк
    Интернирование - процесс помещения строк в пул.
    В Java существует возможность вручную выполнить интернирование строки в пул путем вызова метода intern() у объекта типа String.

    строка, созданная при помощи конструктора хранится непосредственно в куче
    строка, созданная как строковый литерал, хранится в специальном месте кучи — в пуле строк.
    В нем сохраняются уникальные значения строковых литералов. 

    Перед созданием объекта String смотрит есть ли этот объект в пуле стрингов и возвращает его. Иначе создается новый объект в пуле.
    
    Если пул строк уже содержит строку, эквивалентную к нашему объекту
        тогда возвращается ссылка на строку из пула
    Иначе
        объект строки добавляется в пул
    ссылка на этот объект возвращается.

    "" -- когда мы объявляем переменную типа String и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а ссылка на нее возвращена и присвоена переменной.

    NEW -- когда мы создаем экземпляр класса String с помощью оператора new, компилятор размещает строки в куче. При этом каждая строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче или в пуле строк.
  
    До Java версии 7 виртуальная машина размещала пул строк в области памяти под названием PermGen, которая имеет фиксированный размер и не может быть расширена во время выполнения приложения. На эту область памяти не распространяется действие сборщика мусора.
    Начиная с Java 8 пул строк размещается в куче, на которую распространяется процесс сборки мусора. 

    В Java 7 разработчикам предоставили более гибкую возможность настройки (увеличение/уменьшение) размера пула строк. Существуют две возможности посмотреть размер пула:
    -XX:+PrintStringTableStatistics
    -XX:+PrintFlagsFinal

============================================================
13 Что такое профайлер?
============================================================
    Инструмент, который отслеживает внутренние метрики (конструкции и операции байт-кода -- создание объектов, выполнение методов потоков, сборку мусора) Java на уровне JVM 

    Профилирование - это сбор и анализ характеристик работы приложения. Мы запускаем приложение, "подключаемся" к нему, в реальном времени смотрим как оно работает, делаем выводы. Далее предпринмаем меры.

============================================================
14 Как использовать VisualVM?
============================================================

    JVisualVM — упрощённо — это JConsole + профилировщик.
    Инструмент профилирования для приложений Java входит в JDK. По сути является визуальной оберткой над над другими приложениями из JDK (jmap, jstat, jconsole..)
    
    JVisualVM также имеет функцию создания дампа кучи в определенный момент, чтобы вы могли анализировать для каждого класса, сколько памяти он занимает.

    Вкладка Overview
    Вкладка Монитор - CPU, memory, classes, threads
    Вкладка threads + threads dump
    tabs Samler (CPU + Memory)
    tabs Profiler (CPU + Memory + JDBC)
    Можно устаналивать плагины (Visual GC  -- посмотреть на состояние памяти в рельном времени )

    (смотреть сколько процессорного времени занимает вызов разных процедур -- можно поставить фильтр на классы)
    (смотреть сколько занимают места объекты разных типов)


============================================================
15 Чем отличается sampling от profiling? 
============================================================

    sampling 
        создание дампы потоков и анализ трассировки стека. Обычно это быстрее, не требует изменений во время выполнения в вашем байт-коде (что может нарушить его), но также менее точен.
    profiling 
        вносит изменения в байт-код и по этому может изменить поведение программу и более медленный, и более точный

    Профилирование - инструментирование классов и методов, чтобы они «сообщали» всякий раз, когда они запускаются. 
    Это более точно, поскольку он учитывает каждый вызов  метода, а не только те, которые были обнаружены при выполнении дампа. 
    Однако инструментирование означает, что байт-код ваших классов изменяется, и это может нарушить вашу программу. Фактически, по этой причине использование профилирования на больших серверах приложений часто приводит к тому, что все умирает или зависает.

    Инструментирование - это обычно добавление байт-кода в уже существующий байт-код методов, например для сбора информации, или для выполнения каких-то дополнительных действий непосредственно перед, или после действий оригинального метода. Инструментирование может использоваться профайлерами, логгерами, мониторящими агентами и т.д. 


============================================================
16 Что такое benchmark?
============================================================

    Замеры производительности отдельных участков кода с целью улучшения производительности и выявления узких мест
    Для Бенчмаркинга есть специализированные утилиты нример JMH java-microbenchmark-harness.
    Если делать вручноу Бенчмарк, то нужно делать n итераций и делить общее время на n. 
    Не забыть, что JVM может выбросить код внутри метода, если он не используется вне.

    AverageTime Среднее время на операцию.
    SampleTime Время на каждую операцию, включая минимальное и максимальное.
    SingleShotTime Время на единичную операцию.
    Throughput Число операций на единицу времени.

    JVM мы можем добавить аннотацию @Warmup(iterations = <int>)
    Мы можем указать, за какую единицу времени нужно выводить результаты, добавив аннотацию @OutputTimeUnit(<java.util.concurrent.TimeUnit>):
    Создав вспомогательный класс со @Scope(Scope.Benchmarl), мы можем указать параметры, которые нужно замерить:
    @State(Scope.Benchmark)
    public class MyBenchmarkState {
    @Param({ "1", "10", "100", "1000", "10000" })
    public int value;
    }


============================================================
17 finalized
============================================================

    В классе Object есть метод finalize(). 
    Этот метод вызывается перед тем как объект уничтожется, однако является устаревшим и не рекомендуется его использовать. Они замедляют процесс и ничего не гарантируют. 
    Фантомные ссылки предпочтительны для работы по очистке памяти.

    проблемы
    -- недостаток быстроты (Мы можем исчерпать ресурсы до того, как произойдёт очистка, что может привести к системному краху)
    -- зависит от алгоритмов ВМ, снижает переносимость
    -- JVM должна выполнят гораздо больше операций when constructing and destroying objects containing a non-empty finalizer.
    -- If a finalizer бросает исключение, the finalization process stops, оставляя the object in a corrupted state without any notification.


============================================================
18 clone, Deep clone, shallow clone
============================================================

    shallow это default сlone(). 
    Клонирование объекта в классе Object реализовано примитивно – при клонировании создается всего один новый объект: просто создается еще один объект и его полям присваиваются значения полей объекта-образца. 
    Cсылки будут скопированы, дубликаты тех объектов не создаются.

    Чтобы использовать реализацию по умолчанию
    а) Добавить интерфейс Cloneable своему классу. Cloneable – интерфейс-маркер
    б) Переопределить метод clone и вызвать в нем базовую реализацию (super.clone())

    DEEP
    deep clone нужно переопределять самому и копировать и объекты на которые ссылаеюся ссылки в копируемом объекте.

    Cпособы
    1 Переопределение метода clone() и реализация интерфейса Cloneable();
    2 Использование конструктора копирования;
    3 Использовать для клонирования механизм сериализации
    4 есть специальные либы для этого

    требования к клону
    должны быть не равны
    классы должны быть равны
    должны быть равны по equals (не обязательное требование)

    !не вызывается конструктор
    !you can`t work with final-fiels
    считается плохой практикой -- лучше использовать или конструкторы или дополнительные методы, куда можно передать основной объект

============================================================
Слабая гипотезе о поколениях: большинство объектов умирает молодыми. 
Сильная гипотеза о поколениях: объекты из старого поколения редко ссылаются на объекты из молодого поколения.


Что такое утечка памяти и из-за чего она может происходить в Java?
    Утечка памяти происходит когда память выделена для размещения объектов, но после того как объекты уже больше не нужны, эта память не освобождается.