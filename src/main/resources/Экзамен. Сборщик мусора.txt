Экзамен. Сборщик мусора
1 Чем java отличается от с++?
    в контекст нашей беседы можно предположить что речь про автоматическую сборку мусора 

2 Что такое менеджер памяти?
    Менеджер памяти - часть компьютерной программы, обрабатывающая запросы на выделение и освобождение оперативной памяти. Основное назначение менеджера памяти - выделение динамической памяти, то есть памяти под объекты создаваемые во время выполнения программы. Менеджер памяти может быть системный, встроенный в ОС, либо являться частью библиотеки языка программирования или частью среды исполнения. Во многих языках и средах исполнения менеджер памяти также снимает с программиста ответственность за освобождение памяти и берет это на себя, что устраняет ошибки связанные с отсутствием освобождения занятой памяти (утечки) или наоборот преждевременным освобождением памяти.
    
3 Какой механизм используется в Java для управления памятью?
    GC – часть JVM, прикладная программа, которая занимается очищением памяти. Он смотрит на достижимость объекта по ссылке.
4 Опишите процесс работы сборщика мусора?

    Heap
        Young
            eden
            survivor
        Old

    minor GC - when young gerenaration overflowed
    major GC - when old gerenaration overflowed

    Жизненный цикл объекта
    1. new -- выделение памяти и возрат ссылки (EDEN)
    2. п.1 повторяется пока есть место в EDEN 
        если в EDEN место кончилось, запускается minor GC
            -- удаляются unreferensed object
            -- все остальные перемещаются в часть survivor 
            -- move form survivor to survivor (+ aging)
            -- old object move to old generation ("promotion")
            (loop while empty size in OLD generation)
                -- magor GC


5 Какие алгоритмы сборщика вы знаете?
    (чтобы очистить память нужно остановить приложение - событие Stop The World)
    последовательное (Serial)
        -- выполняется только в одном потоке и задействует только один процессор
    параллельное (Parallel)
        -- можем использовать несколько процессоров за счет распараллеливания сборки

    параллелизм (Concurrency) 
        -- работает одновременно с самим приложением
        -- не ждет пока heap заполнится полностью, он периодически производит "мелкие" сборки.
        --   вызывают событие Stop The World, но по времени оно занимает меньше чем если бы сборщик мусора чистил бы полностью heap.

    Вид сборки: 
        -- Compacting -- собрать "живые" объекты в одном месте и очистить оставшуюся часть памяти
            Живые объекты "кучкуются" в одном месте, а остальная часть памяти уничтожается
            + легко выделить память
            - время на компановку объектов в одном месте
        -- Non-compacting (удалить объекты по месту)
            + нет лишних действий
            - дефрагментация памяти
        -- Copying
            скопировать "живые" объекты в отдельную часть памяти, очистив старую часть где они были
            + нет проблем на выделение памятие
            - требуется время на копирование


6 Чем отличаются сборщики мусора?
    Метрики оценки сборщиков мусора

    -- Thoughput (Пропускная способность) - соотношение, показывающее сколько GC может работать БЕЗ полной сборки мусора == (1 - время_на_сборки / общ_время) * 100
    -- GC Overhead - процентное соотношение, показывающее сколько требуется на времени на сборку == 
    (время_на_сборки / общ_время) * 100
    -- Pause Time (или Latency) - время на которое требуется остановить приложение, чтобы произвести сборку
    -- Freequency of collection - количество сборок за все время работы
    -- Promptness -- время между началом сборки мусора и моментом, когда память снова становится доступной для размещения объектов.
    -- Footprint - количество памяти доступное приложению

    Примеры
        1. Serial GC 
            Он является Serial, Stop The World, Copying, т.е. выполняет сборку мусора в одном потоке, вызывается событие Stop The World и используется Copying сборку мусора
            + мин требования
            - медленный
        2. Parallel GC (Parallel, Stop The World, Copying) - в нескольких потоках, требует несколько ядер
        3. CMS (Убран с JDK 14)(Concurrent Mark Sweep, Parallel, Concurrent, Copying) -- спользуется параллелизм, т.е.
                часть heap чистится одновременно с работой приложения.
                + небольшие паузы
                - более высокие сист требования
        4. G1 (усовершенствованная версия CMS. Он является Parallel, Concurrent, Copying)
             используется для серверных приложений требующих быстрого отклика и не терпящих долгих пауз 
            + скорость
            - нужен большой heap (> 4gb)
        5. ZGC ( Parallel, Concurrent, Copying) - появился в ЖДК11
             не требует остановки приложения, .. где допустимы лишь паузы < 10ms
             -  требует сверх большой heap в несколько террабайтов для эффективной работы

7 Расскажите про утилиты для анализа памяти?
    jps -- анализатор запущенных процессов Java Virtual Machine Process Status Tool
    jstat -- редоставляет сводную информацию о состоянии памяти программы.
    jmap -- Memory Map
        
        печатает карты памяти общих объектов или детали памяти кучи для данного процесса, файла ядра или удаленного сервера отладки.
        Эта утилита позволяет увидеть как объекты создаются, какие ожидают удаления, т.е. объекты имеющие непосредственное отношение к памяти.
        Также может сделать дамп памяти, т.е. сохранить ее состояние, как бы "сфоткать" ее.
    jsoncole -- jconsole - утилита отображает состояние изменения памяти. Имеет графический интерфейс
    jhsdb jmap --heap --pid 5720
        Показывает конфигурацию heap:
            Значения настроек при которых heap будет увеличиваться, уменьшаться, максимальный размер heap,
            отношения размеров старого к новому поколению, размел областей survivor,размер Metaspace.
            Можно посмотреть размер памяти в регионах, сколько используется, сколько свободно
    jmap -clstats <pid>.
        Статистика загрузчика классов.
        Количество загруженных классов 213

8 Что такое ссылки? (1.2 в Java -- java.lang.ref.* )
9 Какие типы ссылок вы знаете?
10 Чем они отличаются?
    Strong Reference это самые обычные ссылки которые мы создаем каждый день. Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора. 
        Проблема -- если в программе есть неиспользуемые ссылки на созданные объекты, то они не будут удалены,
    SoftReference 
        для реализации кэшей и когда JVM понадобится память она освободит ее за счет удаления таких объектов. 
        Объекты, на которые ссылаются безопасные ссылки, удаляются только если JVM не хватает памяти, т.е. они могут пережить более одной сборки мусора.
        При нехватке памяти JVM может удалить объекты по этим ссылкам, если на них нет сильных ссылок.
            Есть контракт для данного типа ссылок: GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError
        Корректным использованием безопасных ссылок является сначала получение сильной ссылки на данные, а потом работы с сильной ссылкой.
    WeakReference 
        для хранения метаданных, например для хранения ссылки на ClassLoader.
        Объекты, на которые ссылаются слабые ссылки удаляются сразу, если на них нет сильных или безопасных ссылок.
    PhantomReference 


11 Расскажите про String pool, Int pool.
    пул строк – это набор строк, который хранится в памяти Java heap. 
    Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того, чтобы поместить строку в пул, или получить из пула ссылку на другой объектString с таким же значением.

12 Расскажите о String.intern.
    Метод intern перед созданием объекта String смотрит есть ли этот объект в пуле стрингов и возвращает его. Иначе создается новый объект в пуле.
     Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.

    Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.

13 Расскажите, что такое профайлер?
14 Расскажите, как использовать VisualVM.
15 Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.
16 Расскажите о benchmark. Приведите примеры кода.
17 Расскажите о методы finalized
    В классе Object есть метод finalize(). Этот метод вызывается перед тем как объект уничтожется, однако этот метод является устаревшим и не рекомендуется его использовать.


18 Расскажите о методы clone? Deep clone and shallow clone.
19 Расскажите о Stack, Heap.

Профилирование - это сбор и анализ характеристик работы приложения.