KISS - keep it simple and short
DRY - don't repeat yourselft
YAGNI - You aren't going need it


1 Что такое SOLID?
    Это аббревиатура пяти основных принципов дизайна классов в ООП.
    Эти принципы были впервые изложены Робертом Мартином в книге.
    Главная цель этих принципов 
    -- повысить гибкость вашей архитектуры, 
    -- уменьшить связанность между её компонентами
    -- облегчить повторное использование кода.

    S – Single Responsibility Principle
    O – Open-Closed Principle
    L – Liskov Substitution Principle
    I – Interface Segregation Principle
    D – Dependency Inversion Principle

    Соблюдение этих принципов имеет свою цену. 
    В основном выражается в усложнении кода программы. 
    В реальной жизни, пожалуй, нет такого кода, в котором бы соблюдались все эти принципы сразу. Поэтому помните о балансе

======================================================================================================
2 Для чего используются JavaDoc?
3 Как писать JavaDoc?
======================================================================================================
    Javadoc — стандарт для документирования классов Java.   

    генератор документации в HTML-формате из комментариев исходного кода на Java 

    Комментарий пишется перед документируемым элементом. 
    Комментарий начинается /**.
    Затем пишется текст, описывающий класс, переменную или метод. 
    Затем используем различные дескрипторы. Например @author, @return, @param, @throws, @exception.
    И закрывающий */

    Каждый файл должен иметь объявление об авторских правах в самом начале. 
    Опишите, что делает класс в Javadoc-комментариях.
    Каждый класс и нетривиальный public метод должен содержать Javadoc, по крайней мере с одной фразой, описывающей что он делает.

======================================================================================================
4 Что такое Java code convention?
======================================================================================================

    Документ Oracle по правилам оформления кода. 
    Для написания Javadoc'ов нужно следует придерживаться Sun Javadoc conventions.
    Общий стиль облегчает понимание и поддержание исходного кода, 
    а также упрощает взаимодействие программистов при разработке.

    https://habr.com/ru/post/112042/

======================================================================================================
5 Расскажите про принципы составления Java класса.
======================================================================================================

    Порядок расположения членов класса
    Члены классы располагаются в таком порядке:

    static-поля
    поля
    конструкторы
    static-методы
    перекрытые (overriden) методы
    методы
    get/set методы
    внутренние классы

    1 Class/interface documentation comment ( /**...*/)
    2 Class or interface statement
    3 Class ( static) variables 
        First the public class variables, then the protected, then package level (no access modifier), and then the private.
    4 Instance variables
        First public, then protected, then package level (no access modifier), and then private.
    Constructors
    Methods


    Короткие методы
    Методы должны быть небольшими и решающими конкретную задачу настолько, насколько это возможно. 
    Однако, понятно, что иногда большие методы бывают целесообразны, так что нет строгого ограничения на длину метода. 
    Если метод превышает 40 строк, то вам, возможно, стоит подумать о том, можно ли его разбить на части, не нарушив структуры программы.

    Локальные переменные
    Область видимости локальных переменных должна сводиться к минимуму. 
    Делая это, вы улучшаете читаемость и поддерживаемость кода, а также уменьшаете вероятность ошибок. 
    Каждая переменная должна объявляться в самом глубоком блоке, который окружает все возможные места использования переменной.

    Локальные переменные должны объявляться в том месте, где впервые необходимо её использовать. 
    Почти каждая локальная переменная нуждается в инициализаторе. 
    Если вы еще не знаете, как точно инициализировать переменную, то вам следует отложить её объявление, пока вы это не узнаете.


======================================================================================================
6 SRP (+ нарушения, + последствия нарушения)
======================================================================================================
    У класса должна быть только один мотив для изменения
    1 ПС должна иметь только одну ответственность. 
    2 (вытекает из 1) Должно быть не больше одной причины изменить ПС.

    Принцип единственной ответственности предназначен для борьбы со сложностью. 
    Когда в вашем приложении всего 200 строк, то дизайн как таковой вообще не нужен. 
    Достаточно аккуратно написать 5-7 методов и всё будеть хорошо. 
    Проблемы возникают, когда система растёт и увеличивается в масштабах. 
    Когда класс разрастается, он просто перестаёт помещаться в голове. 
    Навигация затрудняется, на глаза попадаются ненужные детали,связанные с другим аспектом, в результате, количество понятий начинают превышать мозговой стек, и выначинаете терять контроль над кодом.

    НАРУШЕНИЕН-АРУШЕНИЕ-НАРУШЕНИЕ: Если класс делает слишком много вещей сразу, вам приходится изменять его каждый раз, когда одна из этих вещей изменяется. 
    При этом есть риск сломать остальные части класса, которые вы даже не планировали трогать.

======================================================================================================
9 OCP (+ нарушения, + последствия нарушения)
======================================================================================================
    ПС должны быть открыты к расширению, но закрыты к изменению.

    Взаимодействие должно быть через абстракции (интерфейсы, абстрактные классы), за исключением примитивных типов и не изменяемых типов (строки, классы-обертки, классы помеченные final), которые представляют собой состояние объектов.

    Таким образом, расширение достигается за счет полиморфизма. А за счет чего достигается полиморфизм?
    1. Наследование
    2. Интерфейсы и их реализация

    Наследование можно использовать только при устойчивой иерархии классов, всегда подставляйте «is A» между сущностями, чтобы проверить можно ли наследоваться. 
    Если не уверены, то лучше использовать интерфейсы, потому что они дают гибкость. 
    Помните, что при наследовании наследуется состояние объектов, что не всегда нужно. 


    Класс можно назвать открытым, если он доступен для расширения. 
    Например, у вас есть возможность расширить набор его операций или добавить к нему новые поля, создав собственный подкласс.
    В то же время, класс можно назвать закрытым (а лучше сказать законченным), если он готов для использования другими классами. Это означает, что интерфейс класса уже окончательно определён и не будет изменяться в  будущем.

    Но не стоит следовать этому принципу буквально для каждого изменения. Если вам нужно исправить ошибку исходном классе, просто возьмите и сделайте это. Нет смысла решать проблему родителя в дочернем классе

    НАРУШЕНИЕН-АРУШЕНИЕ-НАРУШЕНИЕ: Главная идея этого принципа в том, чтобы не ломать существующий код при внесении изменений в программу.

======================================================================================================
12 LSP 1987 (+ нарушения, + последствия нарушения)
======================================================================================================

    Подклассы должны дополнять, а не замещать поведение базового класса.

    Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода.

    Принцип подстановки — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с остальным кодом программы, который до этого успешно работал, используя объекты базового класса. Это особенно важно при разработке библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код, даже если бы хотели.

    В отличие от других принципов, которые определены очень свободно и имеют массу трактовок, принцип подстановки имеет ряд формальных требований к подклассам и к переопределённым в них методах.

    -- Типы параметров метода подкласса должны совпадать или быть боле абстрактными, чем типы параметров базового метода.
    -- Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода. 
    -- Метод не должен выбрасывать исключения, которые не свойственны базовому методу. 

    -- Предусловия (проверяет корректность аргументов конструктора или метода) не могут быть усилены в подклассе
    -- Постусловия (на возвращаемое значение метода) не могут быть ослаблены в подклассе.
    -- Инварианты (постоянно на протяжении существования объекта) — все условия базового класса - также должны быть сохранены и в подклассе
    -- Подкласс не должен изменять значения приватных полей базового класса.
        Правила 1-2 не распространяются на приватные поля, т.е. когда вы проверяете специфичные только для объекта поля, то вы не нарушаете эти правила. LSP контролирует отношения между классами при наследовании.


    Представляете что нужно будет использовать в коде какие-то специфические реализации и пытаетесь мы мысленно их подставить. 
    Если нет проблем с подстановков, то все отлично. 
    В целом не должно быть завязки на конкретной реализации.

    По своей сути LSP касается интерфейсов и контрактов, а также того, как решить, когда расширять класс или использовать другую стратегию, например композицию, для достижения вашей цели.

    НАРУШЕНИЕН-АРУШЕНИЕ-НАРУШЕНИЕ: LSP гарантирует, что не нарушится принцип OCP относительно взаимосвязи между классами в иерархии.

    Признаки
        -- использование методов getClass(), instance of
        -- если при подстановке нарушается поведение объекта, то это есть нарушение LSP.
        -- Если в коде присутствует адаптация под реализации, то скорее всего код нарушает принцип Лисков. 


======================================================================================================
15 Что такое ISP? (+ нарушения, + последствия нарушения)
======================================================================================================

    Клиенты не должны зависеть от методов, которые они не используют.

    Стремитесь к тому, чтобы интерфейсы были достаточно узкими, чтобы классам не приходилось реализовывать избыточное поведение.

    Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. 
    В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не использут.

    Наследование позволяет классу иметь только один суперкласс, но не ограничивает количество интерфейсов, которые он может реализовать. Большинство объектных языков программирования позволяют классам реализовывать сразу несколько интерфейсов, поэтому нет нужды заталкивать в ваш интерфейс больше поведений, чем он того требует. Вы всегда можете присвоить классу сразу несколько интерфейсов поменьше.

    НАРУШЕНИЕН-АРУШЕНИЕ-НАРУШЕНИЕ: плодить классы с пустой реализацией

======================================================================================================
18 Что такое DIP? (+ нарушения, + последствия нарушения)
======================================================================================================

    Принцип инверсии зависимостей предлагает изменить направление, в котором происходит проектирование структуры

    Классы верхних уровней не должны зависеть от классов нижних уровней. 
    Оба должны зависеть от абстракций. 
    Абстракции не должны зависеть от деталей. 
    Детали должны зависеть от абстракций.

    Обычно при проектировании программ можно выделить два уровня классов.
        -- Классы нижнего уровня -- реализуют базовые операции вроде работы с диском, передачи данных по сети, подключению к базе данных и прочее.
        -- Классы высокого уровня -- содержат сложную бизнес-логику программы, которая опирается на классы низкого уровня для осуществления более простых операций.

    1. Для начала вам нужно описать интерфейс высокоуровневых операций, которые нужны классу бизнес-логики.
        Это позволит вам убрать зависимость класса бизнес-логики от конкретного низкоуровневого класса, заменив её «мягкой» зависимостью от интерфейса.
    2. Низкоуровневый класс, в свою очередь, станет зависимый от интерфейса, определённого бизнес-логикой

    Проще говоря, используемые сущности в вашем коде должны быть абстракциями, т.е. не должно быть прямой зависимости от реализации.
    Это касается:
    - полей классов
    - возвращаемых значений методов
    - аргументов методов и конструкторов
    - создаваемых объектов (вспомните пример из урока про SRP)

    НАРУШЕНИЕН-АРУШЕНИЕ-НАРУШЕНИЕ: вы сперва проектируете классы нижнего уровня, а только потом берётесь за верхний уровень. При таком подходе классы бизнес-логики становятся зависимыми от более примитивных низкоуровневых классов. Каждое изменения в низкоуровневом классе может затронуть классы бизнес-логики, которые его используют.

    Принцип инверсии зависимостей часто идёт в ногу с принципом открытости/закрытости: вы сможете расширять низкоуровневые классы и использовать их вместе с классами бизнес-логики, не изменяя код последних

======================================================================================================
21 Что такое автоматическое тестирование?   
======================================================================================================
    Тестирование, которое использует программные средства для выполнения тестов. 
    Т.е. это программа, которая проверяет правильность другой программы. 
    -скорость, 
    -защита уже написанного кода, 
    -упрощение процесса.

22 Как в Java осуществляется автоматическое тестирование
    Фрейворки модульного тестирования, основными из которых являются JUnit и TestNG.

23 Что такое JUnit? Как использовать для тестирования?
    JUnit это фрейворк для модульного тестирования. 
    Тестом является отдельный класс, public методы которого проверяют ожидаемое поведение тестируемого кода. 
    Тестирующие методы объявляются с помощью аннотаций @Test. 
    В каждом тестирующем методе создается начальное состояние, затем вызываются методы тестируемого кода, далее происходит сверка ожидаемых и реальных результатов. 
    Если результаты совпадают, то тест пройден. 
    Таким образом юнит тесты являются разновидностью документации на то, что ожидается в результате выполнения тестируемого кода.
    В JUnit мы используем разные аннотации, например @Before, @After, @Test.
 

24 Что такое функциональное тестирование чем отличается от модульного?  

    Классификация по уровню детализации приложения:

        Модульное тестирование (тестирование отдельных частей продукта, обычно отдельных функций/методов
        Модульное тестирование — проводится для тестирования какого-либо одного логически выделенного и изолированного элемента (модуля) системы в коде. Проводится самими разработчиками, так как предполагает полный доступ к коду.

        Функциональное тестирование — тестирование корректности работы функциональности приложения, при этом продукт воспринимается как единый «чёрный ящик».

        Интеграционное тестирование — тестирование, направленное на проверку корректности взаимодействия нескольких модулей, объединенных в единое целое.

        Системное тестирование — процесс тестирования системы, на котором проводится не только функциональное тестирование, но и оценка характеристик качества системы — ее устойчивости, надежности, безопасности и производительности.

        Приёмочное тестирование — проверяет соответствие системы потребностям, требованиям и бизнес-процессам пользователя.

        Интеграционное тестирование — тестирование, направленное на проверку корректности взаимодействия нескольких модулей, объединенных в единое целое.


25 Расскажите про принцип TDD?
    Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.

26 Расскажите про принцип BDD?
    Behavior-driven delelopment, то есть разработка через поведение, в котором используется предметно-ориентированный язык, на котором описывается поведение программного продукта и ожидаемые результаты. Особое внимание уделяется описанию поведения системы/модуля в терминах бизнеса(заказчика).
    После написания сценария на полуформальном предметно-ориентированном языке тесты могут автоматически переводиться в Java и запускаться с помощью JUnit или другого фреймворка. 
    Примеры BDD фрейворков: JBehave, Cucumber.

    Основная идея - совмещение в процессе разработки чисто технических интересов и интересов бизнеса. Для общения между этими группами на естественном языке, понятном неспециалисту, формулируется поведение программного продукта и ожидаемые результаты.

    BDD фокусируется на следующих вопросах:

    С чего начинается процесс?
    Что нужно тестировать, а что нет?
    Сколько проверок должно быть совершено за один раз?
    Что можно назвать проверкой?
    Как понять, почему тест не прошёл? Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, которые начинаются с глагола в сослагательном наклонении и следовали бизнес целям. Описание приемочных тестов должно вестись на гибком языке пользовательской истории, например,


27 Что такое тестирование черным ящиком
    функциональность тестируемого приложения тестируется без учета внутренней структуры кода, деталей реализации и знания внутренних путей программного обеспечения. 
    ⦁ тестирование black box (черный ящик) – проведение функционального тестирования без доступа к коду системы,

    Этот тип тестирования полностью основан на требованиях и спецификациях программного обеспечения.
    В BlackBox Testing мы просто фокусируемся на входах и выходах программной системы, не заботясь о внутренних знаниях программ.
